package Week5;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

// undirected graph
public class UnGraph extends Graph {

	public UnGraph(int v) {
		super(v);
		// TODO Auto-generated constructor stub
	}

	// thêm cạnh
	@Override
	public void addEdges(int src, int dest) {
		if (src >= 0 && src < this.numVex && dest >= 0 && dest < this.numVex) {
			this.arr[src][dest] = 1;
			this.arr[dest][src] = 1;
		}
	}

	// xoá cạnh
	@Override
	public void delEdges(int src, int dest) {
		if (src >= 0 && src < this.numVex && dest >= 0 && dest < this.numVex) {
			this.arr[src][dest] = 0;
			this.arr[dest][src] = 0;
		}
	}

	// in số bậc tất cả đỉnh của đồ thị vô hướng
	public String printDegree() {
		String result = "";
		int total = 0;
		for (int i = 0; i < this.arr.length; i++) {
			result += "Đỉnh " + (i + 1) + " có bậc là: " + degree(i) + "\n";
			total += degree(i);
		}
		return result + "==>Tổng bậc: " + total;
	}

	// bậc của đồ thị vô hướng tại 1 đỉnh
	@Override
	public int degree(int src) {
		int sum = 0;
		if (src >= 0 && src <= this.numVex) {
			for (int i = 0; i < this.arr.length; i++) { // duyệt hết tất cả các đỉnh
				sum += this.arr[i][src]; // cột trước hàng sau
			}
		}
		return sum;
	}

	// tổng số bậc của đồ thị vô hướng
	public int totalDegree() {
		int total = 0;
		for (int i = 0; i < this.arr.length; i++) {
			total += degree(i);
		}
		return total;
	}

	// số cạnh của đồ thị vô hướng
	@Override
	public int numberEdgeGraph() {
		return totalDegree() / 2;
	}

	// tuần 2***********************************************************************
	// kiểm tra tính liên thông(dùng DFS)
	@Override
	public boolean isConnected() {
		DFS(0); // xét từ đỉnh đầu tiên
		for (int i = 0; i < arr.length; i++) { // duyệt tất cả các đỉnh
			if (visited[i] == false) { // nếu 1 đỉnh nào đó chưa thăm thì k liên thông
				return false;
			}
		}
		return true;
	}

	// duyệt đồ thị theo chiều sâu(đệ quy)
	@Override
	public void DFS(int vexStart) {
		visited[vexStart] = true; // thăm đỉnh đầu tiên, đánh dấu đã thăm
		// System.out.print(vexStart + 1 + "==>");
		for (int i = 0; i < arr.length; i++) {
			if (arr[vexStart][i] != 0 && visited[i] == false) { // chưa thăm
				DFS(i);
			}
		}

	}

	// đếm thành phần liên thông
	@Override
	public int countConnected() {
		int count = 1;
		DFS(0);
		for (int i = 0; i < arr.length; i++) {
			if (visited[i] == false) {
				DFS(i);
				count++;
			}
		}
		return count;
	}

	// kiểm tra đồ thị g1 có phải con g2
	@Override
	public boolean isSubGraph(Graph g1, Graph g2) {
		ArrayList<Edges> l1 = new ArrayList<>();
		ArrayList<Edges> l2 = new ArrayList<>();
		// số đỉnh hợp lệ ==> xét cạnh
		if (g1.numVex <= g2.numVex) {
			// xét cạnh cho Graph1
			for (int i = 0; i < g1.numVex; i++) {
				for (int j = 0; j < g1.numVex; j++) {
					if (g1.arr[i][j] != 0) {
						l1.add(new Edges(i, j));

					}
				}
			}
			// xét cạnh cho Graph2
			for (int i = 0; i < g2.numVex; i++) {
				for (int j = 0; j < g2.numVex; j++) {
					if (g2.arr[i][j] != 0) {
						l2.add(new Edges(i, j));

					}
				}
			}
			System.out.println(l1.toString());
			System.out.println(l2.toString());
			// check addEdges in l2 contain l1
			int count = 0;
			for (int i = 0; i < l1.size(); i++) {
				for (int j = 0; j < l2.size(); j++) {
					if (l1.get(i).toString().equalsIgnoreCase(l2.get(j).toString())) {
						count++;
					}
				}
			}
			if (count == l1.size()) {
				return true;
			} else {
				return false;
			}
		}
		return false;

	}

	// tìm thành phần liên thông
	@Override
	public void findConnection() {
//		ArrayList<Integer> vex = new ArrayList<>();
//		for (int i = 1; i <= numVex; i++) {
//			vex.add(i);
//		}
//		int count = 0;
//		visited = new boolean[numVex];
//		while (vex.size() != 0) {
//			count++;
//			System.out.println("thanh phan lien thong thu: " + count);
//			System.out.println(DFS(vex.get(0)));
//			vex.removeAll(vexVisited);
//		}
//		System.out.println("so thanh phan lien thong cua do thi: " + count);
	}

	// kiểm tra đồ thị lưỡng phân
	@Override
	public boolean isBir() {
		int[] colorArr = new int[numVex]; // biến màu
		// b1:
		for (int i = 0; i < colorArr.length; i++) {
			colorArr[i] = -1; // -1 no color, 1 is the first color, 0 is the second color
		}
		// b2: thực hiện tô màu
		for (int i = 0; i < colorArr.length; i++) {
			for (int j = 0; j < colorArr.length; j++) {
				if (arr[i][j] != 0 && colorArr[j] == -1) {
					if (colorArr[i] == 1) {
						colorArr[j] = 0;
					} else {
						colorArr[j] = 1;
					}

				}
			}
		}
		// b3: kiểm tra
		for (int i = 0; i < colorArr.length; i++) {
			for (int j = 0; j < colorArr.length; j++) {
				if (arr[i][j] != 0 && colorArr[i] == colorArr[j]) {
					return false;
				}
			}
		}
		return true;

	}

	@Override
	public void DFS_Stack(int start) {
		Stack<Integer> stack = new Stack<>();
		ArrayList<Integer> list = new ArrayList<>();
		stack.push(start);
		list.add(start);
		visited[start] = true;
		while (!stack.isEmpty()) {
			int k;
			int count = 0;
			k = stack.peek();// Lấy k ra khỏi Stack, lấy nhưng k xoá
			for (int i = 0; i < this.numVex; i++) {
				if ((this.arr[k][i] != 0) && visited[i] == false) { // xd đỉnh kề mà chưa xét
					stack.push(i); // đưa đỉnh kề chưa xét i vào Stack
					list.add(i);
					visited[i] = true; // đánh dấu đã duyệt i
					break; // tìm được đỉnh đầu tiên thì break liền
				} else {
					count++;
				}
			}
			if (count == visited.length) { // đi qua tất cả các đỉnh thì xoá Stack
				stack.pop(); // ==> Stack rỗng, kết thúc vòng lập
			}
		}
		for (int e : list) {
			System.out.print((e + 1) + "\t");
		}
	}
	//

	@Override
	public void BFS_Queue(int start) {
		Queue<Integer> queue = new LinkedList<Integer>();
		queue.add(start); // thêm vào hàng đợi
		visited[start] = true;
		while (!queue.isEmpty()) {
			start = queue.poll();
			System.out.print((start + 1) + "\t");
			for (int i = 0; i < arr.length; i++) { // tìm đỉnh kề chưa đi qua lần nào
				if (arr[start][i] != 0 && visited[i] == false) {
					visited[i] = true;
					queue.add(i);
				}
			}
		}

	}

	String s = ""; // để in ra đường đi

	@Override
	public void findPathLong(int src, int dest) {
		visited[src] = true; // đã thăm
		for (int i = 0; i < this.numVex; i++) {
			if (arr[src][i] != 0 && visited[i] == false) { // có cạnh
				visited[i] = true;
				s += (src + 1) + "==>";
				if (i == dest) {
					s += i + 1; // nếu như tới đích
					System.out.println(s);
					break;

				} else
					findPathLong(i, dest);
			}
		}

	}

	// đối với TH rất nhiều Node
	@Override
	public void findPathShortest(int src, int dest) {
		Queue<Integer> queue = new LinkedList<>();
		queue.add(src);
		visited[src] = true;
		ArrayList<Integer> list = new ArrayList<>();
		list.add(src);

		while (!queue.isEmpty()) {
			src = queue.poll();
			System.out.print((src + 1) + "\t");
			if (src == dest)
				break;
			for (int i = 0; i < this.numVex; i++) {
				if (arr[src][i] != 0 && visited[i] == false) {
					list.add(i);
					visited[i] = true;
					queue.add(i);
				}

			}

		}
	}

	// Week4: *****************************************************
	// ktra chu trình Euler
	// G liên thông, tất cả các đỉnh bậc chẵn
	@Override
	public boolean checkCycleEuler() {
		int count = 0;
		if (isConnected() == true && this.numVex > 1) {
			for (int i = 0; i < arr.length; i++) {
				if (degree(i) % 2 == 0) {
					count++;
				}
				if (count == this.numVex) {
					return true;
				}
			}
		}
		return false;

	}

	// kiểm tra đường đi Euler
	// G liên thông, có đúng 2 đỉnh bậc lẻ
	@Override
	public boolean checkEulerPath() {
		int count = 0;
		if (isConnected() == true && this.numVex > 1) {
			for (int i = 0; i < arr.length; i++) {
				if (degree(i) % 2 != 0) {
					count++;
				}
			}
			if (count == 2) {
				return true;
			}
		}
		return false;
	}

	// tìm chu trình Euler
	@Override
	public void findCycleEuler(int start) {
		if (checkCycleEuler() == false) {
			System.out.println("Không có chu trình Euler");
		} else {
			// tạo ma trận mới chứa kích thước ma trận cũ
			// int[][] c;
			Stack<Integer> stack = new Stack<>();
			ArrayList<Integer> list = new ArrayList<>(); // lưu các đỉnh đã duyệt
			stack.push(start);
			list.add(start);
			while (!stack.isEmpty()) {
				int x = stack.pop(); // lấy ra
				for (int i = 0; i < arr.length; i++) { // duyệt tất cả các đỉnh
					if (arr[x][i] != 0) { // có cạnh
						stack.add(i);
						list.add(i);
						arr[x][i] = arr[i][x] = 0;
						x = i;
						i = 0;
					}
					if (i == numVex && !stack.isEmpty()) { // chạy hết các cạnh
						stack.pop();
					}
				}
			}
			System.out.println("Chu trình Euler: ");
			for (Integer c : list) {
				System.out.print((c + 1) + "\t");
			}

		}
	}

	// tìm đường đi Euler (bắt đầu đỉnh bậc lẻ và kết thúc bậc lẻ)
	// đầu tiên xét đỉnh người dùng đưa vào là chẵn hay lẽ
	@Override
	public void findPathEuler(int start) {
		Stack<Integer> stack = new Stack<>();
		ArrayList<Integer> list = new ArrayList<>();
		if (degree(start) % 2 != 0) { // nếu đỉnh bậc lẻ thì push vào
			stack.add(start);
			list.add(start);
		} else { // ko phải đỉnh lẻ ==> kiếm đỉnh bậc lẻ đầu tiên duyệt
			for (int i = 0; i < arr.length; i++) {
				if (degree(i) % 2 != 0) { // nếu đỉnh lẻ
					start = i; // duyệt từ đỉnh lẻ đó
					stack.add(start);
					list.add(start);
					break;
				} else { // không có đỉnh bậc lẻ nào
					System.out.println("Không có đường đi Euler!");
				}
			}
		}
		while (!stack.isEmpty()) {
			int x = stack.pop();
			for (int i = 0; i < arr.length; i++) {
				if (arr[x][i] != 0) {
					stack.add(i);
					list.add(i);
					arr[x][i] = arr[i][x] = 0; // sau khi thêm vào thì xoá đi (vì đối xứng nên arr[x][i] = arr[i][x]
					x = i;
					i = 0;
				}
				if (i == numVex && !stack.isEmpty()) { // chạy hết các cạnh
					stack.pop();
				}
			}
		}
		System.out.println("\nĐường đi Euler: ");
		for (Integer c : list) {
			System.out.print((c + 1) + "\t"); // tại vì chạy ở 0 nên in ra phải +1
		}

	}

	// tuần 5
	// chu trình Hamilton
	// đỉnh >=3, bậc của tất cả đỉnh >= đỉnh/2
	@Override
	public boolean checkCycleHamilton() {
		int count = 0;
		if (this.numVex < 3 && !isConnected()) {
			return false;
		}
		for (int i = 0; i < arr.length; i++) {
			if (degree(i) >= (double) this.numVex / 2) {
				count++;
			}
		}
		if (count == this.numVex) {

			return true;
		}
		return false;

	}

	// đường đi Hamilton
	@Override
	public boolean checkPathHamilton() {
		if (this.numVex < 3 && !isConnected()) {
			return false;
		}
		int count1 = 0;
		int count2 = 0;
		int count3 = 0;
		for (int i = 0; i < arr.length; i++) {
			if (degree(i) == 1) { // đếm đỉnh bậc 1
				count1++;
			}
			if (degree(i) >= (this.numVex / 2) - 1) {
				count2++;
			}
			if (degree(i) <= (this.numVex / 2) - 1) {
				count3++;
			}
		}
		if (count2 == this.numVex) {
			return true;
		}
		if (count1 == 1 && count2 == (numVex - count1)) {
			return true;
		}
		if (count1 == 2 && count3 == 2 && count2 == (this.numVex - count1 - count2)) {
			return true;
		}

		return false;
	}

	// in ra chu trình Hamilton
	// in ra tất cả các chu trình Hamilton
	@Override
	public void findCycleHamiltonAll() {
		if (checkCycleHamilton() == false) {
			System.out.println("Đồ thị ko có chu trình Hamilton!");
		}
		for (int i = 0; i < arr.length; i++) {
			visited[i] = false;
			path[0] = 0;
			visited[0] = true;
		}
		expand(1);

	}

	public void expand(int i) {
		for (int j = 0; j < this.numVex; j++) {
			if (visited[j] == false && this.arr[path[i] - 1][j] > 0) {
				if (i < this.numVex - 1) {
					visited[j] = true;
					expand(i + 1);
					visited[j] = false;
				} else {
					if (this.arr[path[i]][0] > 0) {
						printHamiltonCycle(path);
					}

				}
			}
		}
	}

	// in ra chu trình Hamilton tại 1 đỉnh bất kì
	@Override
	public void findCycleHamiltonAll(int start) {
		// TODO Auto-generated method stub

	}

	// đường đi Hamilton
	@Override
	public void findPathHamilton(int start) {
		// TODO Auto-generated method stub

	}

}
